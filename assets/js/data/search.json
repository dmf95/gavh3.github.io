[ { "title": "Demystifying the Python arrow notation.", "url": "/posts/demystifying-the-python-arrow-notation/", "categories": "Python", "tags": "python", "date": "2021-09-18 00:00:00 -0700", "snippet": "Occasionally I stumble upon something unusual but benign such that it warrants no more reaction than what’s elicited through scrolling r/hmmm.Let me introduce the Python function annotation. Annotations are descriptions or “meta-data” in code to tell the reader what’s going on. Conventionally, in-line comments do that job pretty well. For instance, this is how I would typically annotate a function:def join_two_strings(string1, string2): &#39;&#39;&#39; Joins two strings and returns them as one. Args: string1 (str): first string string2 (str): second string Returns: str &#39;&#39;&#39; return string1 + string2A few things to note: Each variable (input and output) has a specified datatype, but the function doesn’t actually enforce that. Functionally, nothing changes from the Python interpreter’s point of view if I remove the comments. The comments are there because I’m feeling nice.Now, the points I mentioned are also applicable to function annotations, but the example would look like this instead:def join_two_strings(string1: str, string2: str) -&amp;gt; str: return string1 + string2In the above example, we introduce a few characteristics of function annotations. We tell the user what the function expects the data types of string1 and string2 are. We use the arrow -&amp;gt; to annotate the return result of this function which in this case is a str. However, we are not limited to data types as annotations. A declaration like such is equally valid:def join_two_strings(string1: &quot;string 1&quot;, string2: &quot;string 2&quot;) -&amp;gt; &quot;joined string&quot;: return string1 + string2When the code is run, Python ignores all of the annotations, hence they completely optional.Why should I use function annotations over comments?Using function annotations exposes a special attribute __annotations__. Printing the attributes will give us a dictionary mapping the annotations to each argument. This is handy if the function is defined in another script, because you can access this attribute directly instead of reading its definition.def join_two_strings(string1: str, string2: str) -&amp;gt; str: return string1 + string2&amp;gt;&amp;gt;&amp;gt; print(join_two_strings.__annotations__)Output: {string1: str, string2: str, return: str}How about optional arguments?Let’s change our function to accept a third, optional string.def join_two_or_three_strings(s1: str, s2: str, s3: str = None) -&amp;gt; str: if s3: return s1 + s2 + s3 else: return s1 + s2&amp;gt;&amp;gt;&amp;gt; print(join_two_or_three_strings.__annotations__)Output: {s1: str, s2: str, s3: str, return: str}" }, { "title": "Why you need a conda environment, like now.", "url": "/posts/why-you-need-conda-envs/", "categories": "Python", "tags": "python, conda, virtual environments", "date": "2021-09-13 18:25:00 -0700", "snippet": "Before I start, I want to say that this is not a comprehensive guide to Python virtual environments. There are very good resources online already discerning between conda, pip, and virtualenv (see: The Definitive Guide to Conda Environments)Let me start off with a story of how I wasted an entire afternoon after corrupting my conda environment.How I ended up hereRecently, a Python package - vaex was brought to my attention. This library was everything we ever wanted to overcome a technical challenge at work. It’s actually pretty nifty and I would recommend checking out their docs. Long story short, it wasn’t the easiest to install on top of my already-bloated list of installed packages.After Googling error message after error message and god knows how many pip installs I tried.. nothing. I had tried running so many random commands at this point that the next step is one that anyone with a remotely IT-related background would default to - blow it all up.Since I hadn’t been disciplined to properly use environments, every project I’ve ever worked on was built on one aptly named “py3”. On top of the mess that remains of my py3 environment, none of my other project code worked. How I would have done it differently:Creating conda environmentsBefore diving into commands, let’s take a step back and talk a little about Anaconda. By default, Anaconda creates an environment called “base”. You’ll see this in brackets () whenever you open Anaconda Prompt. base contains the version of Python that was installed with Anaconda. I like to treat base as if it were sacred, and just avoid installing additional libraries directly to it.If you navigate to /your/anaconda/path/ on a new Anaconda install, you’ll find a empty folder called envs. Running conda create -n YOUR_ENV_NAME tells Anaconda to create a fresh environment into envs. At this point, the environment is entirely empty (no interpreter, no packages). By the way, a good rule of thumb is to create a new environment for each new project. You can also specify the version of Python that you want for this new environment by slightly modifying the command to conda create -n YOUR_ENV_NAME python=X.X. This method comes with Pip installed automatically inside the environment. Note that you can also create a new environment based off of an existing environment. Now, go ahead and install the packages for your project! Yay, you can now avoid needless package dependency conflicts. Please clap.If you encounter command not found: pip in your new environment, running conda install pip should take care of it.Deleting existing environmentsShould you decide to part ways with your conda environment, first make sure it is deactivated by running conda deactivate. Then, it’s as simple as running conda env remove -n YOUR_ENV_NAME. This should automatically remove the folder inside envs for that environment, but if not, you can manually delete it if you want to reuse the name. Double check with conda env list that the environment you deleted is no longer listed.So, recap thus far: Keep your base environment clean Use conda create -n YOUR_ENV_NAME python=X.X when possible. Install Pip immediately after if you’d rather leave out the python=X.X part For each new project, make a new conda environment. It’s free to do! To delete an environment, call conda deactivate and conda env remove -n YOUR_ENV_NAME. Confirm with conda env list." }, { "title": "I&#39;ve updated .gitignore but the files are still tracked, what&#39;s the deal?", "url": "/posts/refresh-gitignore-cache/", "categories": "Git", "tags": "git", "date": "2021-09-11 16:02:00 -0700", "snippet": "So you’ve changed your project’s .gitignore after accidentally uploading the config file containing the password you use for everything that isn’t your online banking account.You hurriedly create a new git commit -m &quot;changes&quot; and push. Huh? The secrets are still there!Well, let me save you some grief! You need to delete your tracked files cache. Heres how: Run git rm -r --cached . to delete your cache Then git add . to re-add everything, but this time only the files not excluded by .gitignore Then git commit -m &quot;changes but for real this time!&quot; and pushYou’re welcome.Bonus tipgit commit -am &quot;your message here&quot; does the job of two lines! the -am flag tells Git to add all files to staging." } ]
